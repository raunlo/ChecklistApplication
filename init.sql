-- Active: 1749847818946@@127.0.0.1@5432@postgres
CREATE SEQUENCE IF NOT EXISTS checklist_id_sequence START 1 INCREMENT 1;
CREATE SEQUENCE IF NOT EXISTS checklist_share_id_sequence START 1 INCREMENT 1;
CREATE SEQUENCE IF NOT EXISTS checklist_invite_id_sequence START 1 INCREMENT 1;
CREATE SEQUENCE IF NOT EXISTS checklist_item_id_sequence START 1 INCREMENT 1;
CREATE SEQUENCE IF NOT EXISTS checklist_item_row_id_sequence START 1 INCREMENT 1;
CREATE SEQUENCE IF NOT EXISTS template_item_id START 1 INCREMENT 1;
CREATE SEQUENCE IF NOT EXISTS template_item_row_id START 1 INCREMENT 1;
CREATE TABLE IF NOT EXISTS CHECKLIST (
    ID BIGINT PRIMARY KEY,
    OWNER VARCHAR(255) NOT NULL,
    NAME VARCHAR(255) NOT NULL
);

CREATE TABLE IF NOT EXISTS CHECKLIST_ITEM (
    CHECKLIST_ITEM_ID BIGINT PRIMARY KEY,
    CHECKLIST_ID BIGINT NOT NULL,
    CHECKLIST_ITEM_NAME VARCHAR(255) NOT NULL,
    CHECKLIST_ITEM_COMPLETED BOOLEAN NOT NULL DEFAULT FALSE,
    IS_PHANTOM BOOLEAN NOT NULL DEFAULT FALSE,
    NEXT_ITEM_ID BIGINT NULL UNIQUE,
    PREV_ITEM_ID BIGINT NULL UNIQUE,
    FOREIGN KEY (checklist_id) REFERENCES CHECKLIST (ID) ON DELETE CASCADE,
    FOREIGN KEY (NEXT_ITEM_ID) REFERENCES CHECKLIST_ITEM (CHECKLIST_ITEM_ID) ON DELETE SET NULL,
    FOREIGN KEY (PREV_ITEM_ID) REFERENCES CHECKLIST_ITEM (CHECKLIST_ITEM_ID) ON DELETE SET NULL,
    CHECK (NEXT_ITEM_ID IS NULL OR NEXT_ITEM_ID <> CHECKLIST_ITEM_ID),
    CHECK (PREV_ITEM_ID IS NULL OR PREV_ITEM_ID <> CHECKLIST_ITEM_ID)
);

CREATE OR REPLACE VIEW CHECKLIST_ITEMS_ORDERED_VIEW AS
WITH RECURSIVE checklist_items_cte AS (
  SELECT CHECKLIST_ID, CHECKLIST_ITEM_ID, CHECKLIST_ITEM_NAME, CHECKLIST_ITEM_COMPLETED, NEXT_ITEM_ID, 1 AS ORDER_NUMBER
  FROM checklist_item WHERE IS_PHANTOM = FALSE AND NEXT_ITEM_ID IS NULL AND checklist_id = checklist_id

  UNION ALL

  SELECT CHECKLIST_ITEM.CHECKLIST_ID, CHECKLIST_ITEM.CHECKLIST_ITEM_ID, CHECKLIST_ITEM.CHECKLIST_ITEM_NAME, CHECKLIST_ITEM.CHECKLIST_ITEM_COMPLETED, CHECKLIST_ITEM.NEXT_ITEM_ID, ORDER_NUMBER + 1  as ORDER_NUMBER
  FROM CHECKLIST_ITEM, CHECKLIST_ITEMS_CTE
  WHERE IS_PHANTOM = FALSE AND CHECKLIST_ITEM.NEXT_ITEM_ID = CHECKLIST_ITEMS_CTE.CHECKLIST_ITEM_ID AND CHECKLIST_ITEM.checklist_id = CHECKLIST_ITEMS_CTE.checklist_id
)
SELECT CHECKLIST_ID, CHECKLIST_ITEM_ID, CHECKLIST_ITEM_NAME, CHECKLIST_ITEM_COMPLETED, ORDER_NUMBER FROM checklist_items_cte;

CREATE TABLE IF NOT EXISTS CHECKLIST_ITEM_ROW (
    CHECKLIST_ITEM_ROW_ID BIGINT PRIMARY KEY,
    CHECKLIST_ITEM_ID BIGINT NOT NULL,
    CHECKLIST_ITEM_ROW_NAME VARCHAR(255) NOT NULL,
    CHECKLIST_ITEM_ROW_COMPLETED BOOLEAN NOT NULL DEFAULT FALSE,
    FOREIGN KEY (CHECKLIST_ITEM_ID) REFERENCES CHECKLIST_ITEM (CHECKLIST_ITEM_ID) ON DELETE CASCADE);

CREATE TABLE IF NOT EXISTS TEMPLATE_ITEM (
    ID BIGINT PRIMARY KEY,
    NAME VARCHAR(255) NOT NULL
);

CREATE TABLE IF NOT EXISTS TEMPLATE_ITEM_ROW (
    ID BIGINT PRIMARY KEY,
    TEMPLATE_ITEM_ID BIGINT NOT NULL,
    NAME VARCHAR(255) NOT NULL,
    FOREIGN KEY (TEMPLATE_ITEM_ID) REFERENCES TEMPLATE_ITEM (ID)
);

CREATE UNIQUE INDEX IF NOT EXISTS uq_checklist_next
  ON CHECKLIST_ITEM (CHECKLIST_ID, NEXT_ITEM_ID)
  WHERE NEXT_ITEM_ID IS NOT NULL;

CREATE UNIQUE INDEX IF NOT EXISTS uq_checklist_prev
  ON CHECKLIST_ITEM (CHECKLIST_ID, PREV_ITEM_ID)
  WHERE PREV_ITEM_ID IS NOT NULL;


CREATE TABLE IF NOT EXISTS CHECKLIST_SHARE (
    ID BIGINT PRIMARY KEY DEFAULT NEXTVAL('checklist_share_id_sequence'),
    CHECKLIST_ID BIGINT NOT NULL REFERENCES CHECKLIST(ID) ON DELETE CASCADE,
    SHARED_BY_USER_ID VARCHAR(255) NOT NULL,  -- Owner's Google ID
    SHARED_WITH_USER_ID VARCHAR(255) NOT NULL,  -- Recipient's Google ID
    PERMISSION_LEVEL VARCHAR(20) NOT NULL DEFAULT 'READ' CHECK (PERMISSION_LEVEL IN ('READ', 'WRITE', 'DELETE', 'SUPER')),
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(CHECKLIST_ID, SHARED_WITH_USER_ID)  -- Prevent duplicate shares
);

CREATE TABLE IF NOT EXISTS CHECKLIST_INVITE (
    ID BIGINT PRIMARY KEY DEFAULT NEXTVAL('checklist_invite_id_sequence'),
    CHECKLIST_ID BIGINT NOT NULL REFERENCES CHECKLIST(ID) ON DELETE CASCADE,
    NAME VARCHAR(100) NULL,  -- Optional friendly name for the invite
    INVITE_TOKEN VARCHAR(64) NOT NULL UNIQUE,  -- Secure random token
    CREATED_BY VARCHAR(255) NOT NULL,  -- Google ID of creator
    CREATED_AT TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    EXPIRES_AT TIMESTAMP NULL,  -- NULL means never expires
    CLAIMED_BY VARCHAR(255) NULL,  -- Google ID of claimer
    CLAIMED_AT TIMESTAMP NULL,
    IS_SINGLE_USE BOOLEAN NOT NULL DEFAULT TRUE,
    CHECK (CLAIMED_AT IS NULL OR CLAIMED_BY IS NOT NULL)  -- If claimed_at is set, claimed_by must be set
);

-- Index for fast lookup by token (most common query)
CREATE INDEX IF NOT EXISTS idx_checklist_invite_token ON CHECKLIST_INVITE(INVITE_TOKEN);

-- Index for finding active invites by checklist
CREATE INDEX IF NOT EXISTS idx_checklist_invite_active ON CHECKLIST_INVITE(CHECKLIST_ID, CLAIMED_AT, EXPIRES_AT) 
    WHERE CLAIMED_AT IS NULL;

ALTER TABLE CHECKLIST_INVITE ADD COLUMN IF NOT EXISTS NAME VARCHAR(255) NOT NULL DEFAULT '';

-- Session-based authentication tables
CREATE SEQUENCE IF NOT EXISTS session_id_sequence START 1 INCREMENT 1;

CREATE TABLE IF NOT EXISTS app_user (
    user_id VARCHAR(255) PRIMARY KEY,
    email VARCHAR(255) NOT NULL UNIQUE,
    name VARCHAR(255),
    photo_url VARCHAR(500),
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_user_email ON app_user(email);

CREATE TABLE IF NOT EXISTS user_session (
    id BIGINT PRIMARY KEY DEFAULT NEXTVAL('session_id_sequence'),
    session_id VARCHAR(255) NOT NULL UNIQUE,
    user_id VARCHAR(255) NOT NULL REFERENCES app_user(user_id) ON DELETE CASCADE,
    access_token_encrypted BYTEA NOT NULL,
    refresh_token_encrypted BYTEA NOT NULL,
    access_token_expires_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    last_activity_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP NOT NULL,
    is_invalidated BOOLEAN NOT NULL DEFAULT FALSE,
    invalidated_at TIMESTAMP,
    invalidation_reason VARCHAR(100)
);

-- Indexes for performance (partial indexes on active sessions only)
CREATE INDEX IF NOT EXISTS idx_session_session_id ON user_session(session_id) WHERE is_invalidated = FALSE;
CREATE INDEX IF NOT EXISTS idx_session_user_id ON user_session(user_id) WHERE is_invalidated = FALSE;
CREATE INDEX IF NOT EXISTS idx_session_expiry ON user_session(expires_at) WHERE is_invalidated = FALSE;
CREATE INDEX IF NOT EXISTS idx_session_last_activity ON user_session(last_activity_at) WHERE is_invalidated = FALSE;